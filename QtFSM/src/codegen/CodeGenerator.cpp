#include "CodeGenerator.h"
#include "../model/FSM.h"
#include "../model/State.h"
#include "../model/Transition.h"
#include <QTextStream>

CodeGenerator::CodeGenerator(QObject *parent)
    : QObject(parent)
{
}

CodeGenerator::~CodeGenerator()
{
}

QString CodeGenerator::generate(const FSM *fsm)
{
    if (!fsm || fsm->states().isEmpty()) {
        return "// Error: No FSM or states to generate";
    }

    QString code;
    QTextStream out(&code);

    QString fsmName = fsm->name().isEmpty() ? "MyFSM" : fsm->name();

    // Header comment
    out << "// Auto-generated FSM Config - " << fsmName << "\n";
    out << "// Generated by QtFSM Designer\n\n";

    // Includes
    out << "#include <functional>\n";
    out << "#include <iostream>\n";
    out << "#include <string>\n";
    out << "#include <unordered_map>\n";
    out << "#include <vector>\n\n";

    // Config structures
    out << "// --- Simple config structures ---\n";
    out << "struct TransitionConfig {\n";
    out << "    std::string event;\n";
    out << "    std::string to;\n";
    out << "    std::string guard;\n";
    out << "    std::string action;\n";
    out << "};\n\n";

    out << "struct StateConfig {\n";
    out << "    std::string name;\n";
    out << "    double x;\n";
    out << "    double y;\n";
    out << "    bool isFinal;\n";
    out << "    std::string entry;\n";
    out << "    std::string exit;\n";
    out << "    std::vector<TransitionConfig> transitions;\n";
    out << "};\n\n";

    out << "struct FSMConfig {\n";
    out << "    std::string initial;\n";
    out << "    std::unordered_map<std::string, StateConfig> states;\n";
    out << "};\n\n";

    // Action registry
    out << "class ActionRegistry {\n";
    out << "public:\n";
    out << "    using ActionFn = std::function<void()>;\n";
    out << "    using GuardFn = std::function<bool()>;\n\n";
    out << "    void registerAction(const std::string& name, ActionFn fn) {\n";
    out << "        actions_[name] = std::move(fn);\n";
    out << "    }\n\n";
    out << "    void registerGuard(const std::string& name, GuardFn fn) {\n";
    out << "        guards_[name] = std::move(fn);\n";
    out << "    }\n\n";
    out << "    void callAction(const std::string& name) const {\n";
    out << "        if (name.empty()) return;\n";
    out << "        auto it = actions_.find(name);\n";
    out << "        if (it != actions_.end()) {\n";
    out << "            it->second();\n";
    out << "        }\n";
    out << "    }\n\n";
    out << "    bool evalGuard(const std::string& name) const {\n";
    out << "        if (name.empty()) return true;\n";
    out << "        auto it = guards_.find(name);\n";
    out << "        if (it != guards_.end()) {\n";
    out << "            return it->second();\n";
    out << "        }\n";
    out << "        return false;\n";
    out << "    }\n\n";
    out << "private:\n";
    out << "    std::unordered_map<std::string, ActionFn> actions_;\n";
    out << "    std::unordered_map<std::string, GuardFn> guards_;\n";
    out << "};\n\n";

    // Runtime
    out << "// --- FSM runtime that interprets config ---\n";
    out << "class ConfigFSM {\n";
    out << "public:\n";
    out << "    explicit ConfigFSM(FSMConfig cfg, ActionRegistry* registry = nullptr)\n";
    out << "        : config_(std::move(cfg)), registry_(registry) {\n";
    out << "        current_ = config_.initial;\n";
    out << "        onEntry(current_);\n";
    out << "    }\n\n";
    out << "    void dispatch(const std::string& event) {\n";
    out << "        const auto& state = config_.states.at(current_);\n";
    out << "        for (const auto& t : state.transitions) {\n";
    out << "            if (t.event == event && guardOk(t.guard)) {\n";
    out << "                onExit(current_);\n";
    out << "                callAction(t.action);\n";
    out << "                std::cout << \"Transition: \" << state.name\n";
    out << "                          << \" --(\" << event << \")--> \"\n";
    out << "                          << config_.states.at(t.to).name << \"\\n\";\n";
    out << "                current_ = t.to;\n";
    out << "                onEntry(current_);\n";
    out << "                return;\n";
    out << "            }\n";
    out << "        }\n";
    out << "        std::cout << \"No transition from \" << state.name\n";
    out << "                  << \" on event '\" << event << \"'\\n\";\n";
    out << "    }\n\n";
    out << "    const std::string& currentStateId() const { return current_; }\n";
    out << "    const std::string& currentStateName() const {\n";
    out << "        return config_.states.at(current_).name;\n";
    out << "    }\n\n";
    out << "private:\n";
    out << "    void onEntry(const std::string& stateId) {\n";
    out << "        if (!registry_) return;\n";
    out << "        registry_->callAction(config_.states.at(stateId).entry);\n";
    out << "    }\n\n";
    out << "    void onExit(const std::string& stateId) {\n";
    out << "        if (!registry_) return;\n";
    out << "        registry_->callAction(config_.states.at(stateId).exit);\n";
    out << "    }\n\n";
    out << "    bool guardOk(const std::string& guard) const {\n";
    out << "        if (!registry_) return guard.empty();\n";
    out << "        return registry_->evalGuard(guard);\n";
    out << "    }\n\n";
    out << "    void callAction(const std::string& action) const {\n";
    out << "        if (!registry_) return;\n";
    out << "        registry_->callAction(action);\n";
    out << "    }\n\n";
    out << "    FSMConfig config_;\n";
    out << "    ActionRegistry* registry_;\n";
    out << "    std::string current_;\n";
    out << "};\n\n";

    // Config instance
    out << "// --- FSM config instance ---\n";
    out << "FSMConfig cfg;\n";
    if (fsm->initialState()) {
        out << "cfg.initial = \"" << escapeStringLiteral(fsm->initialState()->id()) << "\";\n";
    } else {
        out << "cfg.initial = \"\";\n";
    }

    for (State *state : fsm->states()) {
        QString stateId = escapeStringLiteral(state->id());
        QString stateName = escapeStringLiteral(state->name());
        QString entryAction = escapeStringLiteral(state->entryAction());
        QString exitAction = escapeStringLiteral(state->exitAction());
        QString isFinal = state->isFinal() ? "true" : "false";
        QString posX = QString::number(state->position().x(), 'f', 2);
        QString posY = QString::number(state->position().y(), 'f', 2);

        out << "cfg.states[\"" << stateId << "\"] = StateConfig{\n";
        out << "    \"" << stateName << "\",\n";
        out << "    " << posX << ",\n";
        out << "    " << posY << ",\n";
        out << "    " << isFinal << ",\n";
        out << "    \"" << entryAction << "\",\n";
        out << "    \"" << exitAction << "\",\n";
        out << "    {\n";

        if (!state->transitions().isEmpty()) {
            for (Transition *trans : state->transitions()) {
                QString eventName = escapeStringLiteral(trans->event());
                QString targetId = escapeStringLiteral(trans->targetState()->id());
                QString guard = escapeStringLiteral(trans->guard());
                QString action = escapeStringLiteral(trans->action());
                out << "        {\"" << eventName << "\", \"" << targetId
                    << "\", \"" << guard << "\", \"" << action << "\"},\n";
            }
        }

        out << "    }\n";
        out << "};\n\n";
    }

    // Usage example
    out << "// --- Example usage ---\n";
    out << "// ActionRegistry registry;\n";
    out << "// registry.registerAction(\"action_name\", []() { /* ... */ });\n";
    out << "// registry.registerGuard(\"guard_name\", []() { return true; });\n";
    out << "// ConfigFSM fsm(cfg, &registry);\n";
    out << "// std::cout << \"Initial: \" << fsm.currentStateName() << \"\\n\";\n";
    out << "// fsm.dispatch(\"EVENT\");\n";

    return code;
}

QString CodeGenerator::sanitizeName(const QString &name)
{
    QString result = name;
    result.replace(" ", "");
    result.replace("-", "_");
    result.replace(".", "_");
    if (result.isEmpty() || !result[0].isLetter()) {
        result = "State_" + result;
    }
    return result;
}

QString CodeGenerator::escapeStringLiteral(const QString &value)
{
    QString result = value;
    result.replace("\\", "\\\\");
    result.replace("\"", "\\\"");
    result.replace("\n", "\\n");
    result.replace("\r", "\\r");
    result.replace("\t", "\\t");
    return result;
}
