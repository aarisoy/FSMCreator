#include "CodeGenerator.h"
#include "../model/FSM.h"
#include "../model/State.h"
#include "../model/Transition.h"
#include <QTextStream>

CodeGenerator::CodeGenerator(QObject *parent)
    : QObject(parent)
{
}

CodeGenerator::~CodeGenerator()
{
}

QString CodeGenerator::generate(const FSM *fsm)
{
    if (!fsm || fsm->states().isEmpty()) {
        return "// Error: No FSM or states to generate";
    }
    
    QString code;
    QTextStream out(&code);
    
    QString fsmName = fsm->name().isEmpty() ? "MyFSM" : fsm->name();
    QString baseStateName = fsmName + "StateBase";
    QString contextName = fsmName + "Context";
    
    // Header comment
    out << "// Auto-generated FSM Code - " << fsmName << "\n";
    out << "// Generated by QtFSM Designer\n\n";
    
    // Includes
    out << "#include <memory>\n";
    out << "#include <string>\n\n";
    
    // Event structure
    out << "// Event structure\n";
    out << "struct Event {\n";
    out << "    std::string type;\n";
    out << "    // Add your event data here\n";
    out << "};\n\n";
    
    // Forward declaration
    out << "class " << contextName << ";\n\n";
    
    // Base State class
    out << "// Base State class\n";
    out << "class " << baseStateName << " {\n";
    out << "public:\n";
    out << "    virtual ~" << baseStateName << "() = default;\n\n";
    out << "    virtual void onEntry(" << contextName << "* context) {}\n";
    out << "    virtual void onExit(" << contextName << "* context) {}\n";
    out << "    virtual " << baseStateName << "* handle(" << contextName << "* context, const Event& event) = 0;\n";
    out << "    virtual std::string getName() const = 0;\n";
    out << "};\n\n";
    
    // Generate concrete state classes
    for (State *state : fsm->states()) {
        QString stateName = sanitizeName(state->name());
        QString className = stateName + "State";
        
        out << "// " << stateName << " State\n";
        out << "class " << className << " : public " << baseStateName << " {\n";
        out << "public:\n";
        out << "    void onEntry(" << contextName << "* context) override {\n";
        if (!state->entryAction().isEmpty()) {
            out << "        " << state->entryAction() << "\n";
        } else {
            out << "        // Entry action for " << stateName << "\n";
        }
        out << "    }\n\n";
        
        out << "    void onExit(" << contextName << "* context) override {\n";
        if (!state->exitAction().isEmpty()) {
            out << "        " << state->exitAction() << "\n";
        } else {
            out << "        // Exit action for " << stateName << "\n";
        }
        out << "    }\n\n";
        
        out << "    " << baseStateName << "* handle(" << contextName << "* context, const Event& event) override {\n";
        
        // Find transitions from this state
        // Use state->transitions() directly as we updated the model to support it
        // previous logic relied on FSM::transitions() which might be empty if not strictly maintained
        if (!state->transitions().isEmpty()) {
            for (Transition *trans : state->transitions()) {
                QString targetName = sanitizeName(trans->targetState()->name());
                QString eventName = trans->event().isEmpty() ? "EVENT" : trans->event();
                
                out << "        if (event.type == \"" << eventName << "\"";
                if (!trans->guard().isEmpty()) {
                    out << " && " << trans->guard();
                }
                out << ") {\n";
                
                if (!trans->action().isEmpty()) {
                    out << "            " << trans->action() << "\n";
                }
                out << "            return new " << targetName << "State();\n";
                out << "        }\n";
            }
        } else {
            out << "        // No transitions defined\n";
        }
        
        out << "        return nullptr; // Stay in current state\n";
        out << "    }\n\n";
        
        out << "    std::string getName() const override { return \"" << stateName << "\"; }\n";
        out << "};\n\n";
    }
    
    // FSM Context class
    out << "// FSM Context Manager\n";
    out << "class " << contextName << " {\n";
    out << "private:\n";
    out << "    " << baseStateName << "* currentState;\n\n";
    out << "public:\n";
    out << "    " << contextName << "() {\n";
    
    // Set initial state
    if (fsm->initialState()) {
        QString initialName = sanitizeName(fsm->initialState()->name());
        out << "        currentState = new " << initialName << "State();\n";
        out << "        currentState->onEntry(this);\n";
    } else {
        out << "        currentState = nullptr;\n";
    }
    out << "    }\n\n";
    
    out << "    ~" << contextName << "() {\n";
    out << "        delete currentState;\n";
    out << "    }\n\n";
    
    out << "    void processEvent(const Event& event) {\n";
    out << "        if (currentState) {\n";
    out << "            " << baseStateName << "* newState = currentState->handle(this, event);\n";
    out << "            if (newState) {\n";
    out << "                currentState->onExit(this);\n";
    out << "                delete currentState;\n";
    out << "                currentState = newState;\n";
    out << "                currentState->onEntry(this);\n";
    out << "            }\n";
    out << "        }\n";
    out << "    }\n\n";
    
    out << "    std::string getCurrentStateName() const {\n";
    out << "        return currentState ? currentState->getName() : \"None\";\n";
    out << "    }\n";
    out << "};\n\n";
    
    // Usage example
    out << "// Usage Example:\n";
    out << "// " << contextName << " fsm;\n";
    out << "// Event evt{\"EVENT_NAME\"};\n";
    out << "// fsm.processEvent(evt);\n";
    
    return code;
}

QString CodeGenerator::sanitizeName(const QString &name)
{
    QString result = name;
    result.replace(" ", "");
    result.replace("-", "_");
    result.replace(".", "_");
    if (result.isEmpty() || !result[0].isLetter()) {
        result = "State_" + result;
    }
    return result;
}
