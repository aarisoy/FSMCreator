#include "../src/model/FSM.h"
#include "../src/model/State.h"
#include "../src/model/Transition.h"
#include "../src/parsing/CodeParser.h"
#include <gtest/gtest.h>

TEST(CodeParserTest, ParsesConfigBasedFSM) {
  QString testCode = R"(
// Auto-generated FSM Config - DemoFSM
// Generated by QtFSM Designer

#include <functional>
#include <iostream>
#include <string>
#include <unordered_map>
#include <vector>

struct TransitionConfig {
    std::string event;
    std::string to;
    std::string guard;
    std::string action;
};

struct StateConfig {
    std::string name;
    double x;
    double y;
    bool isFinal;
    std::string entry;
    std::string exit;
    std::vector<TransitionConfig> transitions;
};

struct FSMConfig {
    std::string initial;
    std::unordered_map<std::string, StateConfig> states;
};

FSMConfig cfg;
cfg.initial = "S1";
cfg.states["S1"] = StateConfig{
    "Idle",
    10.00,
    20.00,
    false,
    "onEnterIdle",
    "onExitIdle",
    {
        {"start", "S2", "canStart", "doStart"},
    }
};

cfg.states["S2"] = StateConfig{
    "Running",
    200.00,
    120.00,
    true,
    "",
    "",
    {
        {"stop", "S1", "", ""},
    }
};
)";

  CodeParser parser;
  FSM *fsm = parser.parse(testCode);

  ASSERT_NE(fsm, nullptr) << "Parser should successfully parse config-based FSM";
  EXPECT_EQ(fsm->name(), "DemoFSM");
  ASSERT_EQ(fsm->states().size(), 2);
  ASSERT_EQ(fsm->transitions().size(), 2);

  State *s1 = fsm->stateById("S1");
  State *s2 = fsm->stateById("S2");
  ASSERT_NE(s1, nullptr);
  ASSERT_NE(s2, nullptr);

  EXPECT_EQ(s1->name(), "Idle");
  EXPECT_EQ(s1->position().x(), 10.00);
  EXPECT_EQ(s1->position().y(), 20.00);
  EXPECT_TRUE(s1->isInitial());
  EXPECT_FALSE(s1->isFinal());
  EXPECT_EQ(s1->entryAction(), "onEnterIdle");
  EXPECT_EQ(s1->exitAction(), "onExitIdle");

  EXPECT_EQ(s2->name(), "Running");
  EXPECT_TRUE(s2->isFinal());

  bool foundStart = false;
  bool foundStop = false;
  for (Transition *t : fsm->transitions()) {
    if (t->sourceState() == s1 && t->targetState() == s2 &&
        t->event() == "start" && t->guard() == "canStart" &&
        t->action() == "doStart") {
      foundStart = true;
    }
    if (t->sourceState() == s2 && t->targetState() == s1 &&
        t->event() == "stop") {
      foundStop = true;
    }
  }

  EXPECT_TRUE(foundStart);
  EXPECT_TRUE(foundStop);

  delete fsm;
}

TEST(CodeParserTest, RejectsMissingInitial) {
  QString testCode = R"(
FSMConfig cfg;
cfg.states["S1"] = StateConfig{ "Idle", 0.0, 0.0, false, "", "", {} };
)";

  CodeParser parser;
  FSM *fsm = parser.parse(testCode);

  ASSERT_EQ(fsm, nullptr);
  EXPECT_EQ(parser.lastError(), "Missing cfg.initial assignment");
}
