#include "../src/model/FSM.h"
#include "../src/model/State.h"
#include "../src/parsing/CodeParser.h"
#include <QString>
#include <gtest/gtest.h>

// GTest for FSM Parser Stress Test (Config-based)
TEST(FSMParserStressTest, HandlesComplexConfig) {
  QString trickyCode = R"(
// Auto-generated FSM Config - StressFSM
// Generated by QtFSM Designer

#include <functional>
#include <iostream>
#include <string>
#include <unordered_map>
#include <vector>

struct TransitionConfig {
    std::string event;
    std::string to;
    std::string guard;
    std::string action;
};

struct StateConfig {
    std::string name;
    double x;
    double y;
    bool isFinal;
    std::string entry;
    std::string exit;
    std::vector<TransitionConfig> transitions;
};

struct FSMConfig {
    std::string initial;
    std::unordered_map<std::string, StateConfig> states;
};

FSMConfig cfg;
cfg.initial = "S1";

cfg.states["S1"] = StateConfig{
    "Alpha",
    -10.00,
    20.00,
    false,
    "enterA",
    "exitA",
    {
        {"go", "S2", "", ""},
        {"jump", "S3", "g1", "a1"},
    }
};

cfg.states["S2"] = StateConfig{
    "Beta",
    100.50,
    -200.25,
    false,
    "",
    "",
    {
        {"back", "S1", "", ""},
    }
};

cfg.states["S3"] = StateConfig{
    "Gamma",
    300.00,
    400.00,
    true,
    "enterG",
    "exitG",
    {
    }
};
  )";

  CodeParser parser;
  FSM *fsm = parser.parse(trickyCode);

  ASSERT_NE(fsm, nullptr) << "FSM should be created from config";
  EXPECT_EQ(fsm->name(), "StressFSM");
  EXPECT_EQ(fsm->states().size(), 3);
  EXPECT_EQ(fsm->transitions().size(), 3);

  State *s1 = fsm->stateById("S1");
  State *s2 = fsm->stateById("S2");
  State *s3 = fsm->stateById("S3");

  ASSERT_NE(s1, nullptr);
  ASSERT_NE(s2, nullptr);
  ASSERT_NE(s3, nullptr);

  EXPECT_TRUE(s1->isInitial());
  EXPECT_TRUE(s3->isFinal());

  delete fsm;
}
