#include "../src/model/FSM.h"
#include "../src/parsing/CodeParser.h"
#include <QString>
#include <gtest/gtest.h>


// GTest for User Generated Code Parsing
TEST(UserCodeParsingTest, ParsesGeneratedFSMCode) {
  QString code = R"(
// Auto-generated FSM Code - MyFSM
// Generated by QtFSM Designer

#include <memory>
#include <string>

// Event structure
struct Event {
    std::string type;
    // Add your event data here
};

class MyFSMContext;

// Base State class
class MyFSMStateBase {
public:
    virtual ~MyFSMStateBase() = default;

    virtual void onEntry(MyFSMContext* context) {}
    virtual void onExit(MyFSMContext* context) {}
    virtual MyFSMStateBase* handle(MyFSMContext* context, const Event& event) = 0;
    virtual std::string getName() const = 0;
};

// State1 State
class Init : public MyFSMStateBase {
public:
    void onEntry(MyFSMContext* context) override {
        // Entry action for State1
    }

    void onExit(MyFSMContext* context) override {
        // Exit action for State1
    }

    MyFSMStateBase* handle(MyFSMContext* context, const Event& event) override {
        if (event.type == "zattiriko") {
            return new Run();
        }
        return nullptr; // Stay in current state
    }

    std::string getName() const override { return "State1"; }
};

// State2 State
class Run : public MyFSMStateBase {
public:
    void onEntry(MyFSMContext* context) override {
        // Entry action for State2
    }

    void onExit(MyFSMContext* context) override {
        // Exit action for State2
    }

    MyFSMStateBase* handle(MyFSMContext* context, const Event& event) override {
        // No transitions defined
        return nullptr; // Stay in current state
    }

    std::string getName() const override { return "State2"; }
};

// FSM Context Manager
class MyFSMContext {
private:
    MyFSMStateBase* currentState;

public:
    MyFSMContext() {
        currentState = nullptr;
    }

    ~MyFSMContext() {
        delete currentState;
    }

    void processEvent(const Event& event) {
        if (currentState) {
            MyFSMStateBase* newState = currentState->handle(this, event);
            if (newState) {
                currentState->onExit(this);
                delete currentState;
                currentState = newState;
                currentState->onEntry(this);
            }
        }
    }

    std::string getCurrentStateName() const {
        return currentState ? currentState->getName() : "None";
    }
};
  )";

  CodeParser parser;
  FSM *fsm = parser.parse(code);

  ASSERT_NE(fsm, nullptr)
      << "Should successfully parse user-generated FSM code";

  // Should extract 2 states: Init and Run
  EXPECT_EQ(fsm->states().size(), 2) << "Should have 2 states";

  // Verify state names
  bool hasInit = false;
  bool hasRun = false;
  for (State *state : fsm->states()) {
    if (state->name() == "Init")
      hasInit = true;
    if (state->name() == "Run")
      hasRun = true;
  }

  EXPECT_TRUE(hasInit) << "Should have Init state";
  EXPECT_TRUE(hasRun) << "Should have Run state";

  // Should have 1 transition from Init to Run
  EXPECT_GT(fsm->transitions().size(), 0)
      << "Should have at least one transition";

  // Find the transition
  bool foundTransition = false;
  for (Transition *t : fsm->transitions()) {
    if (t->sourceState()->name() == "Init" &&
        t->targetState()->name() == "Run" && t->event() == "zattiriko") {
      foundTransition = true;
      break;
    }
  }

  EXPECT_TRUE(foundTransition)
      << "Should have transition from Init to Run on 'zattiriko' event";

  delete fsm;
}
